<!DOCTYPE html><html><head><title>Express - api参考</title><link rel="stylesheet" href="style.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Open+Sans:300,400,600,700&amp;subset=latin,latin-ext"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.0/jquery.min.js"></script><script src="app.js"></script><script src="retina.js"></script></head><body class="inner"><div class="bar"></div><section id="content"><header><section id="logo"><span class="express">express<em>3.0.0</em></span><span class="description"> 
web application framework for <a href="http://nodejs.org">node  </a></span></section><nav class="clearfix"><a href="/" class=""> 首页</a><a href="/api.html" class="active"> API 参考</a><a href="/guide.html" class=""> 新手指南 </a><a href="/applications.html" class=""> 应用展示</a><a href="/community.html" class=""> 社区</a><a href="/faq.html" class=""> 问答</a></nav></header><ul id="menu"><li id="app-api"> <a href="#express">Application</a><ul id="app-menu"><li><a href="#express">express()</a></li><li><a href="#app.set">app.set()</a></li><li><a href="#app.get">app.get()</a></li><li><a href="#app.enable">app.enable()</a></li><li><a href="#app.disable">app.disable()</a></li><li><a href="#app.enabled">app.enabled()</a></li><li><a href="#app.disabled">app.disabled()</a></li><li><a href="#app.configure">app.configure()</a></li><li><a href="#app.use">app.use()</a></li><li><a href="#app.engine">app.engine()</a></li><li><a href="#app.param">app.param()</a></li><li><a href="#app-settings">application settings</a></li><li><a href="#app.VERB">application routing</a></li><li><a href="#app.all">app.all()</a></li><li><a href="#app.locals">app.locals</a></li><li><a href="#app.render">app.render()</a></li><li><a href="#app.routes">app.routes</a></li><li><a href="#app.listen">app.listen()</a></li></ul></li><li id="req-api"> <a href="#req.params">Request</a><ul id="req-menu"><li><a href="#req.params">req.params</a></li><li><a href="#req.query">req.query</a></li><li><a href="#req.body">req.body</a></li><li><a href="#req.files">req.files</a></li><li><a href="#req.param">req.param()</a></li><li><a href="#req.route">req.route</a></li><li><a href="#req.cookies">req.cookies</a></li><li><a href="#req.signedCookies">req.signedCookies</a></li><li><a href="#req.get">req.get()</a></li><li><a href="#req.accepts">req.accepts()</a></li><li><a href="#req.accepted">req.accepted</a></li><li><a href="#req.is">req.is()</a></li><li><a href="#req.ip">req.ip</a></li><li><a href="#req.ips">req.ips</a></li><li><a href="#req.path">req.path</a></li><li><a href="#req.host">req.host</a></li><li><a href="#req.fresh">req.fresh</a></li><li><a href="#req.stale">req.stale</a></li><li><a href="#req.xhr">req.xhr</a></li><li><a href="#req.protocol">req.protocol</a></li><li><a href="#req.secure">req.secure</a></li><li><a href="#req.subdomains">req.subdomains</a></li><li><a href="#req.originalUrl">req.originalUrl</a></li><li><a href="#req.acceptedLanguages">req.acceptedLanguages</a></li><li><a href="#req.acceptedCharsets">req.acceptedCharsets</a></li><li><a href="#req.acceptsCharset">req.acceptsCharset()</a></li><li><a href="#req.acceptsLanguage">req.acceptsLanguage()</a></li></ul></li><li id="res-api"> <a href="#res.status">Response</a><ul id="res-menu"><li><a href="#res.status">res.status()</a></li><li><a href="#res.set">res.set()</a></li><li><a href="#res.get">res.get()</a></li><li><a href="#res.cookie">res.cookie()</a></li><li><a href="#res.clearCookie">res.clearCookie()</a></li><li><a href="#res.redirect">res.redirect()</a></li><li><a href="#res.charset">res.charset</a></li><li><a href="#res.send">res.send()</a></li><li><a href="#res.json">res.json()</a></li><li><a href="#res.jsonp">res.jsonp()</a></li><li><a href="#res.type">res.type()</a></li><li><a href="#res.format">res.format()</a></li><li><a href="#res.attachment">res.attachment()</a></li><li><a href="#res.sendfile">res.sendfile()</a></li><li><a href="#res.download">res.download()</a></li><li><a href="#res.links">res.links()</a></li><li><a href="#res.locals">res.locals</a></li><li><a href="#res.render">res.render()</a></li></ul></li><li id="middleware-api"><a href="#middleware">Middleware</a><ul id="middleware-menu"><li><a href="#basicAuth">basicAuth()</a></li><li><a href="#bodyParser">bodyParser()</a></li><li><a href="#compress">compress()</a></li><li><a href="#cookieParser">cookieParser()</a></li><li><a href="#cookieSession">cookieSession()</a></li><li><a href="#csrf">csrf()</a></li><li><a href="#directory">directory()</a></li></ul></li></ul><div id="right"><section><h3 id="express">express()</h3><p>创建一个express应用程序
</p><pre class="js"><code>var express = require('express');
var app = express();

app.get('/', function(req, res){
  res.send('hello world');
});

app.listen(3000);</code></pre></section><h2>Application</h2><a name="application"></a><section><h3 id="app.set">app.set(name, value)</h3><p>给<code>name</code>赋值为<code>value</code>
</p><pre class="js"><code>app.set('title', 'My Site');
app.get('title');
// => "My Site"</code></pre></section><section><h3 id="app.get">app.get(name)</h3><p>获取已经设置项<code>name</code>的的值
</p><pre class="js"><code>app.get('title');
// => undefined

app.set('title', 'My Site');
app.get('title');
// => "My Site"</code></pre></section><section><h3 id="app.enable">app.enable(name)</h3><p>设置设置项 <code>name</code> 为 <code>true</code>.
</p><pre class="js"><code>app.enable('trust proxy');
app.get('trust proxy');
// => true</code></pre></section><section><h3 id="app.disable">app.disable(name)</h3><p>设置设置项 <code>name</code> 为 <code>false</code>.
</p><pre class="js"><code>app.disable('trust proxy');
app.get('trust proxy');
// => false</code></pre></section><section><h3 id="app.enabled">app.enabled(name)</h3><p>检查设置项 <code>name</code> 是不是已经激活
</p><pre class="js"><code>app.enabled('trust proxy');
// => false

app.enable('trust proxy');
app.enabled('trust proxy');
// => true</code></pre></section><section><h3 id="app.disabled">app.disabled(name)</h3><p>检查设置项 <code>name</code> 是不是非激活状态
</p><pre class="js"><code>app.disabled('trust proxy');
// => true

app.enable('trust proxy');
app.disabled('trust proxy');
// => false</code></pre></section><section><h3 id="app.configure">app.configure([env], callback)</h3><p>当 <code>env</code> 和  <code>app.get('env')</code>(其实就是 <code>process.env.NODE_ENV</code>)匹配时,执行<code>callback</code>。这个函数被由于历史原因被留下来了，下面列出来的<code>if</code>代码其实更高效。使用了<code>app.set()</code>和其它一些配置函数后这这个函数<em>没有</em>必要存在的。
</p><pre class="js"><code>// all environments
app.configure(function(){
  app.set('title', 'My Application');
})

// development only
app.configure('development', function(){
  app.set('db uri', 'localhost/dev');
})

// production only
app.configure('production', function(){
  app.set('db uri', 'n.n.n.n/prod');
})

</code></pre>更高效的代码如下：<pre class="js"><code>// all environments
app.set('title', 'My Application');

// development only
if ('development' == app.get('env')) {
  app.set('db uri', 'localhost/dev');
}

// production only
if ('production' == app.get('env')) {
  app.set('db uri', 'n.n.n.n/prod');
}</code></pre></section><section><h3 id="app.use">app.use([path], function)</h3><p>使用中间件 <code>function</code>,可选参数<code>path</code>默认为"/"。
</p><pre class="js"><code>var express = require('express');
var app = express();

// 一个简单的 logger
app.use(function(req, res, next){
  console.log('%s %s', req.method, req.url);
  next();
});

// 响应
app.use(function(req, res, next){
  res.send('Hello World');
});

app.listen(3000);
</code></pre><p>这个挂载的路径被从请求里剥离了，对中间件 <code>function</code><strong>不</strong>可见
这么设计的原因是因为中间件可以不需要更改代码就在任意"前缀"路径下执行
</p><p>这里有一个实际应用场景，常见的一个使用是使用./public提供静态文件服务
使用 <code>express.static()</code> 中间件:
</p><pre class="js"><code>// GET /javascripts/jquery.js
// GET /style.css
// GET /favicon.ico
app.use(express.static(__dirname + '/public'));
</code></pre><p>举个栗子，你想把所有的静态文件路径都前缀"/static", 你可以使用“挂载”功能。
如果<code>req.url</code> 不包含这个前缀, 挂载过的中间件<strong>不会</strong>执行。
当<code>function</code>被执行的时候,这个参数不会被传递。
这个只会影响这个函数，后面的中间件里得到的 <code>req.url</code>里将会包含"/static"
</p><pre class="js"><code>// GET /static/javascripts/jquery.js
// GET /static/style.css
// GET /static/favicon.ico
app.use('/static', express.static(__dirname + '/public'));
</code></pre><p>使用 <code>app.use()</code> “定义的”中间件的顺序非常重要，它们将会顺序执行，这个定义了中间件的优先级。
比如说通常 <code>express.logger()</code> 是最先使用的一个组件，纪录每一个请求
</p><pre class="js"><code>app.use(express.logger());
app.use(express.static(__dirname + '/public'));
app.use(function(req, res){
  res.send('Hello');
});
</code></pre><p>如果你想忽略请求静态文件的纪录，但是对于在 <code>logger()</code>之后定义的路由和中间件想继续纪录，只需要简单的把
<code>static()</code> 移到前面就行了:
</p><pre class="js"><code>app.use(express.static(__dirname + '/public'));
app.use(express.logger());
app.use(function(req, res){
  res.send('Hello');
});
</code></pre><p>另一个现实的例子，有可能从多个目录提供静态文件服务，下面的例子中会优先从"./public"目录取文件
</p><pre class="js"><code>app.use(express.static(__dirname + '/public'));
app.use(express.static(__dirname + '/files'));
app.use(express.static(__dirname + '/uploads'));</code></pre></section><section><h3 id="app-settings">settings</h3><p>下面的提供的可以改变Express行为的选项
</p><ul><li><code>env </code>运行时环境，默认为 <code>process.env.NODE_ENV</code> 或者 "development"</li><li><code>trust proxy </code>激活反向代理，默认未激活状态</li><li><code>jsonp callback name </code>修改默认<code>?callback=</code>的jsonp回调的名字</li><li><code>json replacer </code>JSON replacer 替换时的回调, 默认为null</li><li><code>json spaces </code>JSON 响应的空格数量，开发环境下是<code>2</code> , 生产环境是<code>0</code></li><li><code>case sensitive routing </code>激活路由的大小写敏感, 默认是关闭状态， "/Foo" 和"/foo" 是一样的</li><li><code>strict routing </code>激活路由的严格格式, 默认情况下 "/foo" 和 "/foo/" 是被同样对待的 </li><li><code>view cache </code>激活模板缓存，在生产环境中是默认开启的</li><li><code>view engine </code>默认的视图引擎</li><li><code>views </code>视图的目录</li></ul></section><section><h3 id="app.engine">app.engine(ext, callback)</h3><p>注册模板引擎的 <code>callback</code> 用来处理<code>ext</code>扩展名的文件

默认情况下, 根据文件扩展名<code>require()</code> 对应的模板引擎
比如你想渲染一个 "foo.jade" 文件，Express会在内部执行下面的代码，然后会缓存<code>require()</code>，这样就可以提高后面操作的性能
</p><pre class="js"><code>app.engine('jade', require('jade').__express);
</code></pre><p></p>那些没有提供 <code>.__express</code> 的或者你想渲染一个文件的扩展名与模板引擎默认的不一致的时候，你也会用到这个函数。
比如你想用EJS模板引擎来处理 ".html" 后缀的文件:<pre class="js"><code>app.engine('html', require('ejs').renderFile);
</code></pre><p></p>这个例子中EJS提供了一个<code>.renderFile()</code> 方法和Express期待的格式: <code>(path, options, callback)</code>一致, 可以在内部给这个方法取一个别名<code>ejs.__express</code>，这样你就可以使用".ejs" 扩展而不需要做任何改动<p>有些模板引擎没有遵循这种转换， 这里有一个小项目<a href="https://github.com/visionmedia/consolidate.js">consolidate.js</a> 专门把所有的node流行的模板引擎进行了包装，这样它们在Express内部看起来就一样了。
</p><pre class="js"><code>var engines = require('consolidate');
app.engine('haml', engines.haml);
app.engine('html', engines.hogan);</code></pre></section><section><h3 id="app.param">app.param([name], callback)</h3><p>路由参数的处理逻辑。比如当 <code>:user</code> 出现在一个路由路径中，你也许会自动载入加载用户的逻辑，并把它放置到 <code>req.user</code> , 或者校验一下输入的参数是否正确。
</p><p>下面的代码片段展示了<code>callback</code>很像中间件，但是在参数里多加了一个值，这里名为<code>id</code>.
它会尝试加载用户信息，然后赋值给<code>req.user</code>, 否则就传递错误<code>next(err)</code>.
</p><pre class="js"><code>app.param('user', function(req, res, next, id){
  User.find(id, function(err, user){
    if (err) {
      next(err);
    } else if (user) {
      req.user = user;
      next();
    } else {
      next(new Error('failed to load user'));
    }
  });
});
</code></pre><p>另外你也可以只传一个<code>callback</code>, 这样你就有机会改变 <code>app.param()</code> API.
比如<a href="http://github.com/visionmedia/express-params">express-params</a>定义了下面的回调，这个允许你使用一个给定的正则去限制参数。
</p><p>下面的这个例子有一点点高级，检查如果第二个参数是一个正则，返回一个很像上面的"user"参数例子行为的回调函数。
</p><pre class="js"><code>app.param(function(name, fn){
  if (fn instanceof RegExp) {
    return function(req, res, next, val){
      var captures;
      if (captures = fn.exec(String(val))) {
        req.params[name] = captures;
        next();
      } else {
        next('route');
      }
    }
  }
});
</code></pre><p>这个函数现在可以非常有效的用来校验参数，或者提供正则捕获后的分组。
</p><pre class="js"><code>app.param('id', /^\d+$/);

app.get('/user/:id', function(req, res){
  res.send('user ' + req.params.id);
});

app.param('range', /^(\w+)\.\.(\w+)?$/);

app.get('/range/:range', function(req, res){
  var range = req.params.range;
  res.send('from ' + range[1] + ' to ' + range[2]);
});</code></pre></section><section><h3 id="app.VERB">app.VERB(path, [callback...], callback)</h3><p><code>app.VERB()</code> 方法为Express提供路由方法, <strong>VERB</strong> 是指某一个HTTP 动作,
比如 <code>app.post()</code>。 可以提供多个callbacks,这多个callbacks都将会被平等对待
，它们的行为跟中间件一样，也有一个例外的情况，如果某一个callback执行了<code>next('route')</code>，它后面的callback就被忽略。这种情形会应用在当满足一个路由前缀，但是不需要处理这个路由，于是把它向后传递。
</p><p>下面的代码片段展示最简单的路由定义。Express 会把路径字符串转为正则表达式，然后在符合规则的请求到达时立即使用。
请求参数<em>不会</em> 被考虑进来，比如 "GET /" 会匹配下面的这个路由, 而"GET /?name=tobi"同样也会匹配。
</p><pre class="js"><code>app.get('/', function(req, res){
  res.send('hello world');
});
</code></pre><p>同样也可以使用正则表达式，并且它能够在你指定特定路径的时候发挥大作用。
比如下面的例子可以匹配"GET /commits/71dbb9c" ， 同时也能匹配 "GET /commits/71dbb9c..4c084f9".
</p><pre class="js"><code>app.get(/^\/commits\/(\w+)(?:\.\.(\w+))?$/, function(req, res){
  var from = req.params[0];
  var to = req.params[1] || 'HEAD';
  res.send('commit range ' + from + '..' + to);
});
</code></pre><p>可以传递一些回调，这对复用一些加载资源、校验的中间件很有用。
</p><pre class="js"><code>app.get('/user/:id', user.load, function(){
  // ... 
})
</code></pre><p>这些回调同样可以通过数组传递，简单的放置在数组中即可。
</p><pre class="js"><code>var middleware = [loadForum, loadThread];

app.get('/forum/:fid/thread/:tid', middleware, function(){
  // ...
})

app.post('/forum/:fid/thread/:tid', middleware, function(){
  // ...
})</code></pre></section><section><h3 id="app.all">app.all(path, [callback...], callback)</h3><p>这个方法很像<code>app.VERB()</code> , 但是它匹配所有的HTTP动作 
</p><p>这个方法在给特定前缀路径或者任意路径上处理时会特别有用。


比如你想把下面的路由放在所有其它路由之前，它需要所有从这个路由开始的加载验证，并且自动加载一个用户
记住所有的回调都不应该被当作终点， <code>loadUser</code> 能够被当作一个任务，然后<code>next()</code>去匹配接下来的路由。
</p><pre class="js"><code>app.all('*', requireAuthentication, loadUser);
</code></pre><p>Or the equivalent:
</p><pre class="js"><code>app.all('*', requireAuthentication)
app.all('*', loadUser);
</code></pre><p>另一个非常赞的例子是全局白名单函数。这里有一个例子跟前一个很像，但是它限制前缀为"/api": </p><pre class="js"><code>app.all('/api/*', requireAuthentication);</code></pre></section><section><h3 id="app.locals">app.locals</h3><p>应用程序本地变量会附加给所有的在这个应用程序内渲染的模板。
这是一个非常有用的模板函数，就像应用程序级数据一样。
</p><pre class="js"><code>app.locals.title = 'My App';
app.locals.strftime = require('strftime');
</code></pre><p><code>app.locals</code> 对象是一个JavaScript <code>Function</code>,
执行的时候它会把属性合并到它自身，提供了一种简单展示已有对象作为本地变量的方法
</p><pre class="js"><code>app.locals({
  title: 'My App',
  phone: '1-250-858-9990',
  email: 'me@myapp.com'
});

app.locals.title
// => 'My App'

app.locals.email
// => 'me@myapp.com'
</code></pre><p>默认情况下Express只有一个应用程序级本地变量，它是 <code>settings</code>.
</p><pre class="js"><code>app.set('title', 'My App');
// 在view里使用 settings.title
</code></pre></section><section><h3 id="app.render">app.render(view, [options], callback)</h3><p>渲染 <code>view</code>, <code>callback</code> 用来处理返回的渲染后的字符串。
这个是 <code>res.render()</code> 的应用程序级版本，它们的行为是一样的。
</p><pre class="js"><code>app.render('email', function(err, html){
  // ...
});

app.render('email', { name: 'Tobi' }, function(err, html){
  // ...
});</code></pre></section><section><h3 id="app.routes">app.routes</h3><p><code>app.routes</code> 对象存储了所有的被HTTP verb定义路由。
这个对象可以用在一些内部功能上，比如Express不仅用它来做路由分发，同时在没有<code>app.options()</code>定义的情况下用它来处理默认的<string>OPTIONS</string>行为。
你的应用程序或者框架也可以很轻松的通过在这个对象里移除路由来达到删除路由的目的。
</p><pre class="js"><code>console.log(app.routes)

{ get: 
   [ { path: '/',
       method: 'get',
       callbacks: [Object],
       keys: [],
       regexp: /^\/\/?$/i },
   { path: '/user/:id',
       method: 'get',
       callbacks: [Object],
       keys: [{ name: 'id', optional: false }],
       regexp: /^\/user\/(?:([^\/]+?))\/?$/i } ],
delete: 
   [ { path: '/user/:id',
       method: 'delete',
       callbacks: [Object],
       keys: [Object],
       regexp: /^\/user\/(?:([^\/]+?))\/?$/i } ] }</code></pre></section><section><h3 id="app.listen">app.listen()</h3><p>在给定的主机和端口上监听请求，这个和node的文档<a href="http://nodejs.org/api/http.html#http_server_listen_port_hostname_backlog_callback">http.Server#listen()</a>是一致的
</p><pre class="js"><code>var express = require('express');
var app = express();
app.listen(3000);
</code></pre><p><code>express()</code>返回的<code>app</code>实际上是一个JavaScript<code>Function</code>,它被设计为传给node的http servers作为处理请求的回调函数。因为<code>app</code>不是从HTTP或者HTTPS继承来的，它只是一个简单的回调函数，你可以以同一份代码同时处理HTTP and HTTPS 版本的服务。
</p><pre class="js"><code>var express = require('express');
var https = require('https');
var http = require('http');
var app = express();

http.createServer(app).listen(80);
https.createServer(options, app).listen(443);
</code></pre><p><code>app.listen()</code> 方法只是一个快捷方法，如果你想使用HTTPS，或者同时提供HTTP和HTTPS，可以使用上面的代码
</p><pre class="js"><code>app.listen = function(){
  var server = http.createServer(this);
  return server.listen.apply(server, arguments);
};</code></pre></section><h2>Request</h2><a name="request"></a><section><h3 id="req.params">req.params</h3><p>This property is an array containing properties mapped to the named route "parameters".
For example if you have the route <code>/user/:name</code>, then the "name" property
is available to you as <code>req.params.name</code>. This object defaults to <code>{}</code>.
</p><pre class="js"><code>// GET /user/tj
req.params.name
// => "tj"
</code></pre><p>When a regular expression is used for the route definition, capture groups
are provided in the array using <code>req.params[N]</code>, where <code>N</code>
is the nth capture group. This rule is applied to unnamed wild-card matches
with string routes such as `/file/*`:
</p><pre class="js"><code>// GET /file/javascripts/jquery.js
req.params[0]
// => "javascripts/jquery.js"</code></pre></section><section><h3 id="req.query">req.query</h3><p>This property is an object containing the parsed query-string,
defaulting to <code>{}</code>.
</p><pre class="js"><code>// GET /search?q=tobi+ferret
req.query.q
// => "tobi ferret"

// GET /shoes?order=desc&shoe[color]=blue&shoe[type]=converse
req.query.order
// => "desc"

req.query.shoe.color
// => "blue"

req.query.shoe.type
// => "converse"</code></pre></section><section><h3 id="req.body">req.body</h3><p>This property is an object containing the parsed request body. This feature
is provided by the <code>bodyParser()</code> middleware, though other body
parsing middleware may follow this convention as well. This property
defaults to <code>{}</code> when <code>bodyParser()</code> is used.
</p><pre class="js"><code>// POST user[name]=tobi&user[email]=tobi@learnboost.com
req.body.user.name
// => "tobi"

req.body.user.email
// => "tobi@learnboost.com"

// POST { "name": "tobi" }
req.body.name
// => "tobi"</code></pre></section><section><h3 id="req.files">req.files</h3><p>This property is an object of the files uploaded. This feature
is provided by the <code>bodyParser()</code> middleware, though other body
parsing middleware may follow this convention as well. This property
defaults to <code>{}</code> when <code>bodyParser()</code> is used.
</p><p>For example if a <strong>file</strong> field was named "image",
and a file was uploaded, <code>req.files.image</code> would contain
the following <code>File</code> object:
</p><pre class="js"><code>{ size: 74643,
  path: '/tmp/8ef9c52abe857867fd0a4e9a819d1876',
  name: 'edge.png',
  type: 'image/png',
  hash: false,
  lastModifiedDate: Thu Aug 09 2012 20:07:51 GMT-0700 (PDT),
  _writeStream: 
   { path: '/tmp/8ef9c52abe857867fd0a4e9a819d1876',
     fd: 13,
     writable: false,
     flags: 'w',
     encoding: 'binary',
     mode: 438,
     bytesWritten: 74643,
     busy: false,
     _queue: [],
     _open: [Function],
     drainable: true },
  length: [Getter],
  filename: [Getter],
  mime: [Getter] }
  </code></pre><p>The <code>bodyParser()</code> middleware utilizes the
<a href="https://github.com/felixge/node-formidable">node-formidable</a>
module internally, and accepts the same options. An example of this
is the <code>keepExtensions</code> formidable option, defaulting to <strong>false</strong>
which in this case gives you the filename "/tmp/8ef9c52abe857867fd0a4e9a819d1876" void of
the ".png" extension. To enable this, and others you may pass them to <code>bodyParser()</code>:
</p><pre class="js"><code>app.use(express.bodyParser({ keepExtensions: true, uploadDir: '/my/files' }));</code></pre></section><section><h3 id="req.param">req.param(name)</h3><p>Return the value of param <code>name</code> when present.
</p><pre class="js"><code>// ?name=tobi
req.param('name')
// => "tobi"

// POST name=tobi
req.param('name')
// => "tobi"

// /user/tobi for /user/:name 
req.param('name')
// => "tobi"
</code></pre><p>Lookup is performed in the following order:</p><ul><li><code>req.params</code></li><li><code>req.body</code></li><li><code>req.query</code></li></ul><p>Direct access to <code>req.body</code>, <code>req.params</code>,
and <code>req.query</code> should be favoured for clarity - unless
you truly accept input from each object.</p></section><section><h3 id="req.route">req.route</h3><p>The currently matched <code>Route</code> containing
several properties such as the route's original path
string, the regexp generated, and so on.
</p><pre class="js"><code>app.get('/user/:id?', function(req, res){
  console.log(req.route);
});
</code></pre><p>Example output from the previous snippet:
</p><pre class="js"><code>{ path: '/user/:id?',
  method: 'get',
  callbacks: [ [Function] ],
  keys: [ { name: 'id', optional: true } ],
  regexp: /^\/user(?:\/([^\/]+?))?\/?$/i,
  params: [ id: '12' ] }</code></pre></section><section><h3 id="req.cookies">req.cookies</h3><p>When the <code>cookieParser()</code> middleware is used this object
defaults to <code>{}</code>, otherwise contains the cookies sent by
the user-agent.
</p><pre class="js"><code>// Cookie: name=tj
req.cookies.name
// => "tj"</code></pre></section><section><h3 id="req.signedCookies">req.signedCookies</h3><p>When the <code>cookieParser(secret)</code> middleware is used this object
defaults to <code>{}</code>, otherwise contains the signed cookies sent by
the user-agent, unsigned and ready for use. Signed cookies reside in a different
object to show developer intent, otherwise a malicious attack could be
placed on `req.cookie` values which are easy to spoof. Note that signing
a cookie does not mean it is "hidden" nor encrypted, this simply prevents
tampering as the secret used to sign is private.
</p><pre class="js"><code>// Cookie: user=tobi.CP7AWaXDfAKIRfH49dQzKJx7sKzzSoPq7/AcBBRVwlI3
req.signedCookies.user
// => "tobi"</code></pre></section><section><h3 id="req.get">req.get(field)</h3><p> 
Get the case-insensitive request header <code>field</code>. 
The <em>Referrer</em> and <em>Referer</em> fields are interchangeable.</p><pre class="js"><code>req.get('Content-Type');
// => "text/plain"

req.get('content-type');
// => "text/plain"

req.get('Something');
// => undefined
</code></pre><p>Aliased as <code>req.header(field)</code>.</p></section><section><h3 id="req.accepts">req.accepts(types)</h3><p>Check if the given <code>types</code> are acceptable, returning
the best match when true, otherwise <code>undefined</code> - in which
case you should respond with 406 "Not Acceptable".
</p><p>The <code>type</code> value may be a single mime type string
such as "application/json", the extension name
such as "json", a comma-delimted list or an array. When a list
or array is given the <em>best</em> match, if any is returned.
</p><pre class="js"><code>// Accept: text/html
req.accepts('html');
// => "html"

// Accept: text/*, application/json
req.accepts('html');
// => "html"
req.accepts('text/html');
// => "text/html"
req.accepts('json, text');
// => "json"
req.accepts('application/json');
// => "application/json"

// Accept: text/*, application/json
req.accepts('image/png');
req.accepts('png');
// => undefined

// Accept: text/*;q=.5, application/json
req.accepts(['html', 'json']);
req.accepts('html, json');
// => "json"</code></pre></section><section><h3 id="req.accepted">req.accepted</h3><p>返回一个从高质量到低质量排序的接受媒体类型数组
</p><pre class="js"><code>[ { value: 'application/json',
    quality: 1,
    type: 'application',
    subtype: 'json' },
{ value: 'text/html',
     quality: 0.5,
     type: 'text',
     subtype: 'html' } ]</code></pre></section><section><h3 id="req.is">req.is(type)</h3><p>Check if the incoming request contains the "Content-Type" 
header field, and it matches the give mime <code>type</code>.
</p><pre class="js"><code>// With Content-Type: text/html; charset=utf-8
req.is('html');
req.is('text/html');
req.is('text/*');
// => true

// When Content-Type is application/json
req.is('json');
req.is('application/json');
req.is('application/*');
// => true

req.is('html');
// => false</code></pre></section><section><h3 id="req.ip">req.ip</h3><p>Return the remote address, or when "trust proxy"
is enabled - the upstream address.
</p><pre class="js"><code>req.ip
// => "127.0.0.1"</code></pre></section><section><h3 id="req.ips">req.ips</h3><p>When "trust proxy" is `true`, parse
the "X-Forwarded-For" ip address list
and return an array, otherwise an empty
array is returned.

For example if the value were "client, proxy1, proxy2"
you would receive the array <code>["client", "proxy1", "proxy2"]</code>
where "proxy2" is the furthest down-stream.</p></section><section><h3 id="req.path">req.path</h3><p>Returns the request URL pathname.
</p><pre class="js"><code>// example.com/users?sort=desc
req.path
// => "/users"</code></pre></section><section><h3 id="req.host">req.host</h3><p>返回从"Host"请求头里取的主机名,不包含端口号。
</p><pre class="js"><code>// Host: "example.com:3000"
req.host
// => "example.com"</code></pre></section><section><h3 id="req.fresh">req.fresh</h3><p>Check if the request is fresh - aka Last-Modified and/or the ETag still match,
indicating that the resource is "fresh".
</p><pre class="js"><code>req.fresh
// => true</code></pre></section><section><h3 id="req.stale">req.stale</h3><p>Check if the request is stale - aka Last-Modified and/or the ETag do not match,
indicating that the resource is "stale".
</p><pre class="js"><code>req.stale
// => true</code></pre></section><section><h3 id="req.xhr">req.xhr</h3><p>判断请求头里是否有"X-Requested-With"这样的字段并且值为"XMLHttpRequest", jQuery等库发请求时会设置这个头 
</p><pre class="js"><code>req.xhr
// => true</code></pre></section><section><h3 id="req.protocol">req.protocol</h3><p>Return the protocol string "http" or "https"
when requested with TLS. When the "trust proxy" 
setting is enabled the "X-Forwarded-Proto" header
field will be trusted. If you're running behind
a reverse proxy that supplies https for you this
may be enabled.
</p><pre class="js"><code>req.protocol
// => "http"</code></pre></section><section><h3 id="req.secure">req.secure</h3><p>Check if a TLS connection is established. This is a short-hand for:
</p><pre class="js"><code>'https' == req.protocol;</code></pre></section><section><h3 id="req.subdomains">req.subdomains</h3><p>Return subdomains as an array.
</p><pre class="js"><code>// Host: "tobi.ferrets.example.com"
req.subdomains
// => ["ferrets", "tobi"]</code></pre></section><section><h3 id="req.originalUrl">req.originalUrl</h3><p>This property is much like <code>req.url</code>, however it retains
the original request url, allowing you to rewrite <code>req.url</code>
freely for internal routing purposes. For example the "mounting" feature
of <a href="#app.use">app.use()</a> will rewrite <code>req.url</code> to
strip the mount point.
</p><pre class="js"><code>// GET /search?q=something
req.originalUrl
// => "/search?q=something"</code></pre></section><section><h3 id="req.acceptedLanguages">req.acceptedLanguages</h3><p>返回一个从高质量到低质量排序的接受语言数组
</p><pre class="js"><code>Accept-Language: en;q=.5, en-us
// => ['en-us', 'en']</code></pre></section><section><h3 id="req.acceptedCharsets">req.acceptedCharsets</h3><p>返回一个从高质量到低质量排序的可接受的字符集数组
</p><pre class="js"><code>Accept-Charset: iso-8859-5;q=.2, unicode-1-1;q=0.8
// => ['unicode-1-1', 'iso-8859-5']</code></pre></section><section><h3 id="req.acceptsCharset">req.acceptsCharset(charset)</h3><p>Check if the given <code>charset</code> are acceptable.</p></section><section><h3 id="req.acceptsLanguage">req.acceptsLanguage(lang)</h3><p>Check if the given <code>lang</code> are acceptable.</p></section><h2>Response</h2><a name="response"></a><section><h3 id="res.status">res.status(code)</h3><p>Chainable alias of node's '`res.statusCode=`.
</p><pre class="js"><code>res.status(404).sendfile('path/to/404.png');</code></pre></section><section><h3 id="res.set">res.set(field, [value])</h3><p> 
Set header <code>field</code> to <code>value</code>,
or pass an object to set multiple fields at once.</p><pre class="js"><code>res.set('Content-Type', 'text/plain');

res.set({
  'Content-Type': 'text/plain',
  'Content-Length': '123',
  'ETag': '12345'
})
</code></pre><p>Aliased as <code>res.header(field, [value])</code>.</p></section><section><h3 id="res.get">res.get(field)</h3><p> 
Get the case-insensitive response header <code>field</code>. </p><pre class="js"><code>res.get('Content-Type');
// => "text/plain"</code></pre></section><section><h3 id="res.cookie">res.cookie(name, value, [options])</h3><p>Set cookie <code>name</code> to <code>value</code>, where
which may be a string or object converted to JSON. The <code>path</code>
option defaults to "/".
</p><pre class="js"><code>res.cookie('name', 'tobi', { domain: '.example.com', path: '/admin', secure: true });
res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });
</code></pre><p>The <code>maxAge</code> option is a convenience option for setting "expires"
relative to the current time in milliseconds. The following is equivalent to
the previous example.
</p><pre class="js"><code>res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })
</code></pre><p>An object may be passed which is then serialized as JSON, which is
automatically parsed by the <code>bodyParser()</code> middleware.
</p><pre class="js"><code>res.cookie('cart', { items: [1,2,3] });
res.cookie('cart', { items: [1,2,3] }, { maxAge: 900000 });
</code></pre><p>Signed cookies are also supported through this method. Simply
pass the <code>signed</code> option. When given <code>res.cookie()</code>
will use the secret passed to <code>express.cookieParser(secret)</code>
to sign the value.
</p><pre class="js"><code>res.cookie('name', 'tobi', { signed: true });
</code></pre><p>Later you may access this value through the <a href="#req.signedCookies">req.signedCookie</a>
object.</p></section><section><h3 id="res.clearCookie">res.clearCookie(name, [options])</h3><p>Clear cookie <code>name</code>. The <code>path</code>
option defaults to "/".
</p><pre class="js"><code>res.cookie('name', 'tobi', { path: '/admin' });
res.clearCookie('name', { path: '/admin' });</code></pre></section><section><h3 id="res.redirect">res.redirect([status], url)</h3><p>Redirect to the given <code>url</code> with optional <code>status</code> code
defaulting to 302 "Found".
</p><pre class="js"><code>res.redirect('/foo/bar');
res.redirect('http://example.com');
res.redirect(301, 'http://example.com');
res.redirect('../login');
</code></pre><p>Express supports a few forms of redirection, first being
a fully qualified URI for redirecting to a different site:
</p><pre class="js"><code>res.redirect('http://google.com');
</code></pre><p>The second form is the pathname-relative redirect, for example
if you were on <code>http://example.com/admin/post/new</code>, the 
following redirect to <code>/admin</code> would land you at <code>http://example.com/admin</code>:
</p><pre class="js"><code>res.redirect('/admin');
</code></pre><p>This next redirect is relative to the <code>mount</code> point of the application. For example
if you have a blog application mounted at <code>/blog</code>, ideally it has no knowledge of
where it was mounted, so where a redirect of <code>/admin/post/new</code> would simply give you
<code>http://example.com/admin/post/new</code>, the following mount-relative redirect would give
you <code>http://example.com/blog/admin/post/new</code>:
</p><pre class="js"><code>res.redirect('admin/post/new');
</code></pre><p>Pathname relative redirects are also possible. If you were
on <code>http://example.com/admin/post/new</code>, the following redirect
would land you at <code>http//example.com/admin/post</code>:
</p><pre class="js"><code>res.redirect('..');
</code></pre><p>The final special-case is a <code>back</code> redirect, redirecting back to
the Referer (or Referrer), defaulting to <code>/</code> when missing.
</p><pre class="js"><code>res.redirect('back');

</code></pre></section><section><h3 id="res.charset">res.charset</h3><p>Assign the charset. Defaults to "utf-8".
</p><pre class="js"><code>res.charset = 'value';
res.send('<p>some html</p>');
// => Content-Type: text/html; charset=value</code></pre></section><section><h3 id="res.send">res.send([body|status], [body])</h3><p>Send a response.
</p><pre class="js"><code>res.send(new Buffer('whoop'));
res.send({ some: 'json' });
res.send('<p>some html</p>');
res.send(404, 'Sorry, we cannot find that!');
res.send(500, { error: 'something blew up' });
res.send(200);
</code></pre><p>This method performs a myriad of
useful tasks for simple non-streaming responses such
as automatically assigning the Content-Length unless
previously defined and providing automatic <em>HEAD</em> and
HTTP cache freshness support.
</p><p>When a <code>Buffer</code> is given
the Content-Type is set to "application/octet-stream"
unless previously defined as shown below:
</p><pre class="js"><code>res.set('Content-Type', 'text/html');
res.send(new Buffer('<p>some html</p>'));
</code></pre><p>When a <code>String</code> is given the
Content-Type is set defaulted to "text/html":
</p><pre class="js"><code>res.send('<p>some html</p>');
</code></pre><p>When an <code>Array</code> or <code>Object</code> is
given Express will respond with the JSON representation:
</p><pre class="js"><code>res.send({ user: 'tobi' })
res.send([1,2,3])
</code></pre><p>Finally when a <code>Number</code> is given without
any of the previously mentioned bodies, then a response
body string is assigned for you. For example 200 will
respond will the text "OK", and 204 "Not Found" and so on.
</p><pre class="js"><code>res.send(200)
res.send(204)
res.send(500)</code></pre></section><section><h3 id="res.json">res.json([status|body], [body])</h3><p>Send a JSON response. This method is identical
to <code>res.send()</code> when an object or
array is passed, however it may be used for
explicit JSON conversion of non-objects (null, undefined, etc),
though these are technically not valid JSON.
</p><pre class="js"><code>res.json(null)
res.json({ user: 'tobi' })
res.json(500, { error: 'message' })</code></pre></section><section><h3 id="res.jsonp">res.jsonp([status|body], [body])</h3><p>Send a JSON response with JSONP support. This method is identical
to <code>res.json()</code> however opts-in to JSONP callback
support.
</p><pre class="js"><code>res.jsonp(null)
// => null

res.jsonp({ user: 'tobi' })
// => { "user": "tobi" }

res.jsonp(500, { error: 'message' })
// => { "error": "message" }
</code></pre><p>By default the JSONP callback name is simply <code>callback</code>,
however you may alter this with the <a href="#app-settings">jsonp callback name</a>
setting. The following are some examples of JSONP responses using the same
code:
</p><pre class="js"><code>// ?callback=foo
res.jsonp({ user: 'tobi' })
// => foo({ "user": "tobi" })

app.set('jsonp callback name', 'cb');

// ?cb=foo
res.jsonp(500, { error: 'message' })
// => foo({ "error": "message" })</code></pre></section><section><h3 id="res.type">res.type(type)</h3><p>Sets the Content-Type to the mime lookup of <code>type</code>,
or when "/" is present the Content-Type is simply set to this
literal value.
</p><pre class="js"><code>res.type('.html');
res.type('html');
res.type('json');
res.type('application/json');
res.type('png');</code></pre></section><section><h3 id="res.format">res.format(object)</h3><p>Performs content-negotiation on the request Accept header
field when present. This method uses <code>req.accepted</code>, an array of
acceptable types ordered by their quality values, otherwise the
first callback is invoked. When no match is performed the server
responds with 406 "Not Acceptable", or invokes the <code>default</code>
callback.
</p><p>The Content-Type is set for you when a callback is selected,
however you may alter this within the callback using <code>res.set()</code>
or <code>res.type()</code> etcetera.
</p><p>The following example would respond with <code>{ "message": "hey" }</code>
when the Accept header field is set to "application/json" or "*/json",
however if "*/*" is given then "hey" will be the response.
</p><pre class="js"><code>res.format({
  'text/plain': function(){
    res.send('hey');
  },
  
  'text/html': function(){
    res.send('<p>hey</p>');
  },
  
  'application/json': function(){
    res.send({ message: 'hey' });
  }
});
</code></pre><p>In addition to canonicalized MIME types you may also
use extnames mapped to these types, providing a slightly
less verbose implementation:
</p><pre class="js"><code>res.format({
  text: function(){
    res.send('hey');
  },
  
  html: function(){
    res.send('<p>hey</p>');
  },
  
  json: function(){
    res.send({ message: 'hey' });
  }
});</code></pre></section><section><h3 id="res.attachment">res.attachment([filename])</h3><p>Sets the Content-Disposition header field to "attachment". If
a <code>filename</code> is given then the Content-Type will be
automatically set based on the extname via <code>res.type()</code>,
and the Content-Disposition's "filename=" parameter will be set.
</p><pre class="js"><code>res.attachment();
// Content-Disposition: attachment

res.attachment('path/to/logo.png');
// Content-Disposition: attachment; filename="logo.png"
// Content-Type: image/png</code></pre></section><section><h3 id="res.sendfile">res.sendfile(path, [options], [fn]])</h3><p>Transfer the file at the given <code>path</code>.</p><p>Automatically defaults the Content-Type response header field based
on the filename's extension. The callback <code>fn(err)</code> is 
invoked when the transfer is complete or when an error occurs. 
</p><p>Options:</p><ul><li><code>maxAge</code> in milliseconds defaulting to 0</li><li><code>root</code> root directory for relative filenames</li></ul><p>This method provides fine-grained support for file serving
as illustrated in the following example:
</p><pre class="js"><code>app.get('/user/:uid/photos/:file', function(req, res){
  var uid = req.params.uid
    , file = req.params.file;
    
  req.user.mayViewFilesFrom(uid, function(yes){
    if (yes) {
      res.sendfile('/uploads/' + uid + '/' + file);
    } else {
      res.send(403, 'Sorry! you cant see that.');
    }
  });
});</code></pre></section><section><h3 id="res.download">res.download(path, [filename], [fn])</h3><p>Transfer the file at <code>path</code> as an "attachment",
typically browsers will prompt the user for download. The
Content-Disposition "filename=" parameter, aka the one
that will appear in the brower dialog is set to <code>path</code>
by default, however you may provide an override <code>filename</code>.
</p><p>When an error has ocurred or transfer is complete the optional 
callback <code>fn</code> is invoked. This method uses <a href="#res.sendfile">res.sendfile()</a>
to transfer the file.
</p><pre class="js"><code>res.download('/report-12345.pdf');

res.download('/report-12345.pdf', 'report.pdf');

res.download('/report-12345.pdf', 'report.pdf', function(err){
  if (err) {
    // handle error, keep in mind the response may be partially-sent
    // so check res.headerSent
  } else {
    // decrement a download credit etc
  }
});</code></pre></section><section><h3 id="res.links">res.links(links)</h3><p>Join the given <code>links</code> to populate the "Link"
response header field.
</p><pre class="js"><code>res.links({
  next: 'http://api.example.com/users?page=2',
  last: 'http://api.example.com/users?page=5'
});
</code></pre><p>yields:</p><pre><code>Link: &lt;http://api.example.com/users?page=2&gt;; rel="next", 
      &lt;http://api.example.com/users?page=5&gt;; rel="last"</code></pre></section><section><h3 id="res.locals">res.locals</h3><p>Response local variables are scoped to the request, thus only
available to the view(s) rendered during that request / response
cycle, if any. Otherwise this API is identical to <a href="#app.locals">app.locals</a>.
</p><p>This object is useful for exposes request-level information such as the
request pathname, authenticated user, user settings etcetera.
</p><pre class="js"><code>app.use(function(req, res, next){
  res.locals.user = req.user;
  res.locals.authenticated = ! req.user.anonymous;
  next();
});</code></pre></section><section><h3 id="res.render">res.render(view, [locals], callback)</h3><p>Render a <code>view</code> with a callback responding with
the rendered string. When an error occurs <code>next(err)</code>
is invoked internally. When a callback is provided both the possible error
and rendered string are passed, and no automated response is performed.
</p><pre class="js"><code>res.render('index', function(err, html){
  // ...
});

res.render('user', { name: 'Tobi' }, function(err, html){
  // ...
});</code></pre></section><h2>Middleware</h2><a name="middleware"></a><section><h3 id="basicAuth">basicAuth()</h3><p>基本的认证中间件，在<code>req.user</code>里添加用户名
</p><p>用户名和密码的例子:</p><pre class="js"><code>app.use(express.basicAuth('username', 'password'));
</code></pre><p>校验回调:</p><pre class="js"><code>app.use(express.basicAuth(function(user, pass){
  return 'tj' == user & 'wahoo' == pass;
}));
</code></pre><p>异步校验接受参数<code>fn(err, user)</code>,
下面的例子<code>req.user</code> 将会作为user对象传递.
</p><pre class="js"><code>app.use(connect.basicAuth(function(user, pass, fn){
  User.authenticate({ user: user, pass: pass }, fn);
}))</code></pre></section><section><h3 id="bodyParser">bodyParser()</h3><p>支持 JSON, urlencoded和multipart requests的请求体解析中间件。
这个中间件是<code>json()</code>, <code>urlencoded()</code>,和<code>multipart()</code> 这几个中间件的简单封装
</p><pre class="js"><code>app.use(express.bodyParser());

// is equivalent to:
app.use(express.json());
app.use(express.urlencoded());
app.use(express.multipart());</code></pre></section><section><h3 id="compress">compress()</h3><p>通过gzip / deflate压缩响应数据. 
这个中间件应该放置在所有的中间件最前面以保证所有的返回都是被压缩的
</p><pre class="js"><code>app.use(express.logger());
app.use(express.compress());
app.use(express.methodOverride());
app.use(express.bodyParser());</code></pre></section><section><h3 id="cookieParser">cookieParser()</h3><p>解析请求头里的Cookie, 并用cookie名字的键值对形式放在 <code>req.cookies</code>
你也可以通过传递一个<code>secret</code> 字符串激活签名了的cookie
</p><pre class="js"><code>app.use(express.cookieParser());
app.use(express.cookieParser('some secret'));</code></pre></section><section><h3 id="cookieSession">cookieSession()</h3><p>提供一个以cookie为基础的sessions, 设置在<code>req.session</code>里。
这个中间件有以下几个选项:
</p><ul><li><code>key</code> cookie 的名字，默认是 <code>connect.sess</code></li><li><code>secret</code> prevents cookie tampering</li><li><code>cookie</code> session cookie 设置, 默认是 <code>{ path: '/', httpOnly: true, maxAge: null }</code></li><li><code>proxy</code> 当设置安全cookies时信任反向代理 (通过 "x-forwarded-proto")</li></ul><pre class="js"><code>app.use(express.cookieSession());
</code></pre><p>清掉一个cookie, 只需要在响应前把null赋值给session:</p><pre class="js"><code>req.session = null</code></pre></section><section><h3 id="csrf">csrf()</h3><p>CSRF 防护中间件
</p><p>默认情况下这个中间件会产生一个名为"_csrf"的标志，这个标志应该添加到那些需要服务器更改的请求里，可以放在一个表单的隐藏域，请求参数等。这个标志会在访问者的 <code>req.session._csrf</code>属性里进行校验。
</p><p><code>bodyParser()</code> 中间件产生的 <code>req.body</code> , <code>query()</code>产生的<code>req.query</code>,请求头里的"X-CSRF-Token"是默认的 <code>value</code> 函数检查的项
</p><p>这个中间件需要session支持，因此它的代码应该放在<code>session()</code>之后.</p></section><section><h3 id="directory">directory()</h3><p>文件夹服务中间件，用 <code>path</code> 提供服务。
</p><pre class="js"><code>app.use(express.directory('public'))
app.use(express.static('public'))
</code></pre><p>这个中间件接收如下参数：
</p><ul><li><code>hidden</code> 显示隐藏文件，默认为false.</li><li><code>icons</code>  显示图标，默认为false.</li><li><code>filter</code> 在文件上应用这个过滤函数。默认为false.</li></ul></section><!--include ./mw-errorHandler--><!--include ./mw-favicon--><!--include ./mw-json--><!--include ./mw-limit--><!--include ./mw-logger--><!--include ./mw-methodOverride--><!--include ./mw-multipart--><!--include ./mw-query--><!--include ./mw-responseTime--><!--include ./mw-static--><!--include ./mw-timeout--><!--include ./mw-urlencoded--><!--include ./mw-vhost--></div></section><script>var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25235225-1']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + unescape("hm.baidu.com/h.js%3F467c8a7e69297ef8967311f5c8d52672');
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script><a id="top" href="#"><img src="images/arrow.png"></a><footer><div id="footer-content">© 2012 TJ Holowaychuk. 版权所有. <a href="http://jser.me">草依山</a>翻译</div></footer></body></html>